■ 일반함수 <-> 화살표함수

 1.  함수선언식과 함수표현식 의 차이
    : function 키워드 사용하는 방법 (일반함수)
	
    (가) : 함수선언식
        function main() {
            console.log("hello")
        }
        main() //호출방식
		
	 ->> 함수선언식으로 작성된 함수의 특징은 "호이스팅이 된다". 
	     * 호이스팅이란? 함수의 선언을 코드의 최상단으로 끌어올려주는것
		   함수를 코드상에서 선언하기 이전에 main 함수 호출이 가능함.
	 ->> 함수선언식은 함수의 이름을 필수적으로 넣어줘야한다.
         그래서 함수선언식으로 이름이 없는 '익명함수'를 만들 수 없다.
	     그렇다면 익명함수는 어떻게 만들까요? ->> 함수표현식을 사용하면 됩니다.

	(나) : 함수표현식
		const main = function() {
            console.log("Hello")
            }
		main()

	 ->> 함수를 하나의 표현식 안에서 정의하는 것
	     문법적으로는 함수선언식과 굉장히 비슷함. 다만 한가지 큰 차이점은 "익명함수를 만들 수 있다는 점"
	     (+) 이름이 있는 네임드 function()도 가능하다.

     ->> 익명함수를 선언함과 동시에 이 함수를 main이라는 변수에 할당을 해준 걸 볼 수 있다.
	     그래서 변수 이름을 함수의 이름으로 사용해서 함수 호출이 가능하다.

	 ->> 함수표현식의 특징 : 함수선언식과 다르게 호이스팅이 되지않는다는 것.
	                         함수를 정의하기 이전에 함수를 호출하면 JS 에러가 난다.

====================================================================================================================

 2. 화살표함수의 문법
 	장점: 기존의 함수 표현식을 훨씬 더 간결한 문법으로 작성할 수 있음.
	특징: 항상 익명함수임. 함수표현식과 동일하게 할당괸 변수의 이름으로 호출이 가능
	문법: 
		const main = function() {console.log("Hello")}
		main() 
		
         * function 키워드를 삭제하고 + 소괄호와 중괄호 사이에 화살표를 넣어주면 끝!
		const main = () => {console.log("Hello")}
		main() 

	* 예제 : 일반함수 -> 화살표함수로 변경
	  (가) 
        function add(a,b) { return a+b }
	    add()
	        : a와b라는 매개변수를 받고 두 매개변수를 더한 값을 리턴해주는 add함수
	        (화살표함수로 변경하면? )
	    const add = (a,b) => { return a+b } 
	    add()
	        : 간결한 코드의 경우 "중괄호 + 리턴키워드" 생략 가능
	    const add = (a,b) => a+b
	    add()
	
	  (나)
	    function print(text) { console.log(text) }
	    print("hi")
	        : text라는 하나의 매개변수를 받아서 이 txt를 그대로콘솔에 출력해주는 함수
	        (화살표함수로 변경하면? )
	    const print = (text) => console.log(text)
	    print("hi")
	        : 매개변수가 하나뿐이라면 소괄호도 생략이 가능하다. 매개변수가 없거나 2개이상인 경우 불가능

	  (다) 
	    const getObject = () => { return {name : "김나실"} }
	    (X) const getObject = () =>  {name : "김나실"} 
	    (O) const getObject = () =>  ({name : "김나실"}) // 소괄호로 감싸기
	    console.log(getObject())

====================================================================================================================

 3. arguments와 가변인자의 차이

    예시) - 일반함수의 경우
          : 매개변수로 따로 명시해주지 않아도 'arguments'라는 변수를 암묵적으로 전달받음
            function main() {
                console.log(arguments[1]) > 과 같이 인텍스번호로 접근이 가능
                arguments // 콘솔로 찍어보면 main()에 전달해준 1,2,3,이라는 인자가 배열형태로 들어가있음.
            }
            main(1,2,3)

            // arguments 변수는 
            (1) 함수가 전달받은 인자를 담고있는 배열 형태의 객체. 배열은 아님.
            (2) 인자의 개수가 정해지지 않은 가변인자가 전달되는 함수를 쓸 떄 유용

        - 화살표함수의 경우
        : arguments 변수를 전달받지 않음.
            const main = () => {
                console.log(arguments) -> 에러
                console.log(args) -> [1,2,3] 인자가 배열로 출력된다. 동일하게 인덱스로도 접근가능
            }
            main(1,2,3)
            // 가변인자를 처리하고 싶다면 (...args) 나머지 매개변수 구문이라는 걸 사용해주면 됨


====================================================================================================================

 4. this를 어떻게 처리하는가의 차이